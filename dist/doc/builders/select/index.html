<html><head><title>Ship-hold | Select Builder</title><base href="/ship-hold/dist/doc/"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="stylesheet" type="text/css" href="resources/theme.css"/><link rel="stylesheet" type="text/css" href="resources/darkula.css"/><link rel="icon" href="resources/ship-hold-logo.svg"/></head><body><header><div id="logo-wrapper"><img alt="ship-hold logo" src="resources/ship-hold-logo.svg"/><div><span>SHIP</span><span>-</span><span>HOLD</span></div></div><div id="main-navigation-container"><nav><ul><li class="top"><a href="./"><span>Introduction</span></a><ul><li><a href="./#getting-started"><span>Getting started</span></a><ul><li class="leaf"><a href="./#installation"><span>Installation</span></a></li><li class="leaf"><a href="./#initialisation"><span>Initialisation</span></a></li></ul></li><li><a href="./#how-to-read"><span>How to read this documentation</span></a></li></ul></li><li class="top"><a href="builders"><span>Builders</span></a><ul><li><a href="builders#build"><span>.build()</span></a><ul><li class="leaf"><a href="builders#parameterized-query"><span>Parameterized queries</span></a></li></ul></li><li><a href="builders#clone"><span>.clone()</span></a></li><li><a href="builders#with"><span>.with(as, build)</span></a></li><li><a href="builders#common-types"><span>Common types</span></a><ul><li class="leaf"><a href="builders#pointers"><span>Pointers</span></a></li><li class="leaf"><a href="builders#values"><span>Values</span></a></li></ul></li></ul></li><li class="top"><a href="builders/insert"><span>INSERT builder</span></a><ul><li><a href="builders/insert#insert"><span>.insert(map,...othersProps)</span></a></li><li><a href="builders/insert#into"><span>.into(tableName)</span></a></li><li><a href="builders/insert#values"><span>.values(rows)</span></a></li><li><a href="builders/insert#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/update"><span>UPDATE builder</span></a><ul><li><a href="builders/update#update"><span>.update(tableName)</span></a></li><li><a href="builders/update#set"><span>.set(mapOrString, ?value)</span></a></li><li><a href="builders/update#from"><span>.from(...pointers)</span></a></li><li><a href="builders/update#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/update#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/delete"><span>DELETE builder</span></a><ul><li><a href="builders/delete#delete"><span>.delete(tableName)</span></a></li><li><a href="builders/delete#using"><span>.using(...pointers)</span></a></li><li><a href="builders/delete#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/delete#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/select"><span>SELECT builder</span></a><ul><li><a href="builders/select#select"><span>.select(...pointers)</span></a></li><li><a href="builders/select#from"><span>.from(...pointers)</span></a></li><li><a href="builders/select#joins"><span>Joins</span></a><ul><li class="leaf"><a href="builders/select#join"><span>.join(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#left-join"><span>.leftJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#right-join"><span>rightJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#on"><span>.on(leftOperand, operator, rightOperand)</span></a></li></ul></li><li><a href="builders/select#group"><span>Group</span></a><ul><li class="leaf"><a href="builders/select#group-by"><span>.groupBy(...columns)</span></a></li><li class="leaf"><a href="builders/select#having"><span>.having(leftOp, operator, rightOp)</span></a></li></ul></li><li><a href="builders/select#where"><span>.where(leftOp, operator, rightOp)</span></a></li><li><a href="builders/select#pagination"><span>Pagination</span></a><ul><li class="leaf"><a href="builders/select#limit"><span>.limit(size, offset)</span></a></li></ul></li></ul></li><li class="top"><a href="builders/conditions"><span>Conditions builder</span></a><ul><li><a href="builders/conditions#factories"><span>Factories</span></a></li></ul></li><li class="top"><a href="run-queries"><span>Run queries</span></a><ul><li><a href="run-queries#run"><span>.run(params?:object)</span></a></li><li><a href="run-queries#debug"><span>.debug(params?:object)</span></a></li><li><a href="run-queries#stream"><span>.stream(sink: Generator, params?:object)</span></a></li></ul></li><li class="top"><a href="services"><span>Services</span></a><ul><li><a href="services#create-a-service"><span>Create a service</span></a><ul><li class="leaf"><a href="services#service"><span>.service(keyOrDef)</span></a></li></ul></li><li><a href="services#service-builders"><span>Service builders</span></a><ul><li class="leaf"><a href="services#insert"><span>.insert(...args)</span></a></li><li class="leaf"><a href="services#update"><span>.update(prosMap)</span></a></li><li class="leaf"><a href="services#delete"><span>.delete()</span></a></li><li class="leaf"><a href="services#select"><span>.select(...args)</span></a></li></ul></li></ul><li><a href="services#create-relations"><span>Create Relations</span></a><ul><li class="leaf"><a href="services#one-to-one"><span>One to one</span></a></li><li class="leaf"><a href="services#one-to-many"><span>One to many</span></a></li><li class="leaf"><a href="services#many-to-many"><span>Many to many</span></a></li></ul></li><li><a href="services#query-with-associations"><span>Queries with associations</span></a><ul><li class="leaf"><a href="services#include"><span>.include(...associations)</span></a></li></ul></li></li></ul></nav></div></header><main id="main"><h1 id="select-builder">Select Builder</h1><p>The select builder allows you to create <a href="https://devdocs.io/postgresql~10/sql-insert">SELECT queries</a>,
to fetch data from your database.
</p><article><h2 class="method" id="select">.select(...columns:Pointers[])</h2><p>The select builder factory takes as argument a list of <a href="builders#pointers">pointers</a> with or without
alias. You can also use any aggregation function.
</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {toJson} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ship-hold-querybuilder'</span>);

sh
    .select(<span class="hljs-string">'posts.post_id'</span>, <span class="hljs-string">'published_at'</span>, {
        <span class="hljs-attr">as</span>: <span class="hljs-string">'author'</span>,
        <span class="hljs-attr">value</span>: sh.select(toJson(<span class="hljs-string">'"users".*'</span>))
            .from(<span class="hljs-string">'users'</span>)
            .where(<span class="hljs-string">'users.user_id'</span>, <span class="hljs-string">'"posts"."user_id"'</span>)
            .noop()
    })
    .from(<span class="hljs-string">'posts'</span>)
    .build();

<span class="hljs-comment">// { text:</span>
<span class="hljs-comment">//    'SELECT</span>
<span class="hljs-comment">//          "posts"."post_id",</span>
<span class="hljs-comment">//          "published_at",</span>
<span class="hljs-comment">//          (SELECT to_json("users".*) FROM "users" WHERE "users"."user_id" = "posts"."user_id") AS "author"</span>
<span class="hljs-comment">//     FROM "posts"',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">You can also use it without any argument: the wildcard sign <code>*</code> will be used instead.
</p><p class="tip">You can also call <code>.select(...args)</code> as a method of an existing select builder
 with the same effect (if you only know a part of the column list later, when your builder has already been instantiated)
</p></article><article><h2 class="method" id="from">.from(...tables:Pointers[])</h2><p>This method allows you to specify a list of tables. It takes the same kind of arguments as the <a href="builders/select#select">select</a>
method.
</p><pre class="hljs"><code>sh
    .select()
    .from(<span class="hljs-string">'posts'</span>, <span class="hljs-string">'public.users'</span>, {
        <span class="hljs-attr">value</span>: sh.select().from(<span class="hljs-string">'comments'</span>),
        <span class="hljs-attr">as</span>: <span class="hljs-string">'comzz'</span>
    })
    .build();

<span class="hljs-comment">// { text:</span>
<span class="hljs-comment">//    'SELECT * FROM</span>
<span class="hljs-comment">//      "posts",</span>
<span class="hljs-comment">//      "public"."users",</span>
<span class="hljs-comment">//      (SELECT * FROM "comments") AS "comzz"',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">If you use a sub query as a table expression, SQL syntax enforces you to use an alias
</p></article><article><h2 id="joins">Joins</h2><p>There are few methods to join table together. They take the same arguments as the <a href="builders/select#from">from method</a>.
You usually call the <a href="builders/select#on">on method</a> after you have joined a table to apply a join condition but you can
also pass a <em>leftOperand</em> and a <em>rightOperand</em> for usual join equality condition
</p><h3 id="join">.join(table: Pointer, operator?, rightOperand?)</h3><p>Performs an <strong>INNER JOIN</strong>
</p><h3 id="left-join">.leftJoin(table: Pointer, leftOperand?, rightOperand?)</h3><p>Performs a <strong>LEFT OUTER JOIN</strong>
</p><h3 id="right-join">.rightJoin(table: Pointer, leftOperand?, rightOperand?)</h3><p>Performs a <strong>RIGHT OUTER JOIN</strong>
</p><p class="tip">You can of course combine multiple joins.
</p><h3 id="on">.on(leftOperand: Pointer, operator ?: Operator, rightOperand?: value)</h3><p>This method returns a proxy of a condition builder which will be revoked whenever you call a method which does not belong to the condition builder.
See <a href="builders/conditions">conditions builder</a> for more details. You use it to create a join condition on a particular join
</p><pre class="hljs"><code>sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .leftJoin(<span class="hljs-string">'users'</span>)
    .on(<span class="hljs-string">'posts.user_id'</span>, <span class="hljs-string">'"users"."user_id"'</span>)
    .build();

<span class="hljs-comment">// is equivalent to</span>

sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .leftJoin(<span class="hljs-string">'users'</span>, <span class="hljs-string">'posts.user_id'</span>, <span class="hljs-string">'"users"."user_id"'</span>)
    .build();

<span class="hljs-comment">// &gt; { text:</span>
<span class="hljs-comment">//    'SELECT * FROM "posts" LEFT JOIN "users" ON "posts"."user_id" = "users"."user_id"',</span>
<span class="hljs-comment">//   values: [] }</span>


sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .join({
        <span class="hljs-attr">value</span>: sh
            .select()
            .from(<span class="hljs-string">'users'</span>)
            .where(<span class="hljs-string">'users.first_name'</span>, <span class="hljs-string">'Laurent'</span>)
            .noop(),
        <span class="hljs-attr">as</span>: <span class="hljs-string">'Laurents'</span>
    })
    .on(<span class="hljs-string">'posts.user_id'</span>, <span class="hljs-string">'"Laurents".user_id'</span>)
    .and(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2010</span>))
    .build();

<span class="hljs-comment">// &gt; { text:</span>
<span class="hljs-comment">//    `SELECT * FROM "posts" JOIN</span>
<span class="hljs-comment">//     (SELECT * FROM "users" WHERE "users"."first_name" = 'Laurent') AS "Laurents" ON</span>
<span class="hljs-comment">//     "posts"."user_id" = "Laurents".user_id AND "published_at" &gt; '1970-01-01T00:00:02.010Z'`,</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre></article><article><h2 id="group">Group</h2><p>You can decide to group some rows and eventually filter those groups.
</p><h3 class="method" id="group-by">.groupBy(...columns:string[])</h3><p>This method allows you to create a <a href="https://devdocs.io/postgresql~10/sql-select#SQL-GROUPBY">group by</a> clause.
Just pass column names you wish to group by
</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {count} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ship-hold-querybuilder'</span>);

<span class="hljs-comment">// Find how many articles each user has written</span>
sh
    .select(count(<span class="hljs-string">'*'</span>), <span class="hljs-string">'user_id'</span>)
    .from(<span class="hljs-string">'posts'</span>)
    .groupBy(<span class="hljs-string">'user_id'</span>)
    .build();

<span class="hljs-comment">// { text: 'SELECT count(*), "user_id" FROM "posts" GROUP BY "user_id"',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><h3 class="method" id="having">.having(leftOperand: Pointer, operator?, rightOperand?)</h3><p>This method allows you to apply a filter on grouped rows. It defers from <a href="builders/select#where">the where clause</a> which
applies the filter <strong>before</strong> the groups are formed. In the same way as the <a href="builders/select#where">the where method</a> it returns a
proxied condition builder so you can chain conditions
</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {count} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ship-hold-querybuilder'</span>);

<span class="hljs-comment">// only users who have published more than 3 articles</span>
sh
    .select(count(<span class="hljs-string">'*'</span>), <span class="hljs-string">'user_id'</span>)
    .from(<span class="hljs-string">'posts'</span>)
    .groupBy(<span class="hljs-string">'user_id'</span>)
    .having(<span class="hljs-string">'posts.count'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">3</span>)
    .build();

<span class="hljs-comment">// { text:</span>
<span class="hljs-comment">//    'SELECT count(*), "user_id" FROM "posts" GROUP BY "user_id"</span>
<span class="hljs-comment">//     HAVING "posts"."count" &gt; 3',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre></article><article><h2 class="mtehod" id="where">.where(leftOperand, ?operator, ?rightOperand)</h2><p>This method returns a proxy of a condition builder which will be revoked whenever you call a method which does not belong to the condition builder.
See <a href="builders/conditions">conditions builder</a> for more details. You use it to create where clause in your select query
</p><pre class="hljs"><code>sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .where(<span class="hljs-string">'posts.user_id'</span>, <span class="hljs-number">42</span>)
    .and(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2010</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))
    .build();

<span class="hljs-comment">//{ text:</span>
<span class="hljs-comment">//    `SELECT * FROM "posts" WHERE</span>
<span class="hljs-comment">//      "posts"."user_id" = 42 AND</span>
<span class="hljs-comment">//      "published_at" &gt; '2010-02-01T05:00:00.000Z'`,</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre></article><article><h2 class="method" id="order-by">.orderBy(column: string, direction?: SortDirection)</h2><p>This method will let you order the result rows according to a given column. The second argument will give the direction:
it can be <code>'desc'</code> either <code>'asc'</code>. If no direction is provided the direction will be ascendant.
</p><pre class="hljs"><code>sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .orderBy(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'desc'</span>)
    .build();

<span class="hljs-comment">// &gt; { text: 'SELECT * FROM "posts" ORDER BY "published_at" DESC',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">You can combine different order by clauses by calling multiple times the <code>orderBy</code> method.</p></article><article><h2 id="pagination">Pagination</h2><p>To have your rows paginated you have to combine the SQL clauses LIMIT and OFFSET.
In ship hold this is controlled by the <code>limit</code> method
</p><h3 class="method" id="limit">.limit(size: number, offset?: number)</h3><p>The first argument will be the size of you page whereas the second one will be the number of row skipped.
If you don't provide a second argument, no row will be skipped
</p><pre class="hljs"><code><span class="hljs-comment">// fetch the third page (page size = 10) of the latest posts</span>
sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .orderBy(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'desc'</span>)
    .limit(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
    .build();

<span class="hljs-comment">// { text:</span>
<span class="hljs-comment">//    'SELECT * FROM "posts" ORDER BY "published_at" DESC LIMIT 10 OFFSET 20',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">If you want to have consistent pagination result, you <strong>have to</strong> order your result. Otherwise the database
may return different results depending on the query plan it has chosen.</p></article></main></body></html>