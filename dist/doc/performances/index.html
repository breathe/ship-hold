<html><head><title>Ship-hold | Performances</title><base href="/ship-hold/dist/doc/"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="stylesheet" type="text/css" href="resources/theme.css"/><link rel="stylesheet" type="text/css" href="resources/darkula.css"/><link rel="icon" href="resources/ship-hold-logo.svg"/></head><body><header><div id="logo-wrapper"><img alt="ship-hold logo" src="resources/ship-hold-logo.svg"/><div><span>SHIP</span><span>-</span><span>HOLD</span></div></div><div id="main-navigation-container"><nav><ul><li class="top"><a href="./"><span>Introduction</span></a><ul><li><a href="./#getting-started"><span>Getting started</span></a><ul><li class="leaf"><a href="./#installation"><span>Installation</span></a></li><li class="leaf"><a href="./#initialisation"><span>Initialisation</span></a></li></ul></li><li><a href="./#how-to-read"><span>How to read this documentation</span></a></li></ul></li><li class="top"><a href="builders"><span>Builders</span></a><ul><li><a href="builders#build"><span>.build()</span></a><ul><li class="leaf"><a href="builders#parameterized-query"><span>Parameterized queries</span></a></li></ul></li><li><a href="builders#clone"><span>.clone()</span></a></li><li><a href="builders#with"><span>.with(as, build)</span></a></li><li><a href="builders#common-types"><span>Common types</span></a><ul><li class="leaf"><a href="builders#pointers"><span>Pointers</span></a></li><li class="leaf"><a href="builders#values"><span>Values</span></a></li></ul></li></ul></li><li class="top"><a href="builders/insert"><span>INSERT builder</span></a><ul><li><a href="builders/insert#insert"><span>.insert(map,...othersProps)</span></a></li><li><a href="builders/insert#into"><span>.into(tableName)</span></a></li><li><a href="builders/insert#values"><span>.values(rows)</span></a></li><li><a href="builders/insert#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/update"><span>UPDATE builder</span></a><ul><li><a href="builders/update#update"><span>.update(tableName)</span></a></li><li><a href="builders/update#set"><span>.set(mapOrString, ?value)</span></a></li><li><a href="builders/update#from"><span>.from(...pointers)</span></a></li><li><a href="builders/update#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/update#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/delete"><span>DELETE builder</span></a><ul><li><a href="builders/delete#delete"><span>.delete(tableName)</span></a></li><li><a href="builders/delete#using"><span>.using(...pointers)</span></a></li><li><a href="builders/delete#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/delete#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/select"><span>SELECT builder</span></a><ul><li><a href="builders/select#select"><span>.select(...pointers)</span></a></li><li><a href="builders/select#from"><span>.from(...pointers)</span></a></li><li><a href="builders/select#joins"><span>Joins</span></a><ul><li class="leaf"><a href="builders/select#join"><span>.join(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#left-join"><span>.leftJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#right-join"><span>rightJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#on"><span>.on(leftOperand, operator, rightOperand)</span></a></li></ul></li><li><a href="builders/select#group"><span>Group</span></a><ul><li class="leaf"><a href="builders/select#group-by"><span>.groupBy(...columns)</span></a></li><li class="leaf"><a href="builders/select#having"><span>.having(leftOp, operator, rightOp)</span></a></li></ul></li><li><a href="builders/select#where"><span>.where(leftOp, operator, rightOp)</span></a></li><li><a href="builders/select#pagination"><span>Pagination</span></a><ul><li class="leaf"><a href="builders/select#limit"><span>.limit(size, offset)</span></a></li></ul></li></ul></li><li class="top"><a href="builders/conditions"><span>Conditions builder</span></a><ul><li><a href="builders/conditions#factories"><span>Factories</span></a></li></ul></li><li class="top"><a href="run-queries"><span>Run queries</span></a><ul><li><a href="run-queries#run"><span>.run(params?:object)</span></a></li><li><a href="run-queries#debug"><span>.debug(params?:object)</span></a></li><li><a href="run-queries#stream"><span>.stream(sink: Generator, params?:object)</span></a></li></ul></li><li class="top"><a href="services"><span>Services</span></a><ul><li><a href="services#create-a-service"><span>Create a service</span></a><ul><li class="leaf"><a href="services#service"><span>.service(keyOrDef)</span></a></li></ul></li><li><a href="services#service-builders"><span>Service builders</span></a><ul><li class="leaf"><a href="services#insert"><span>.insert(...args)</span></a></li><li class="leaf"><a href="services#update"><span>.update(prosMap)</span></a></li><li class="leaf"><a href="services#delete"><span>.delete()</span></a></li><li class="leaf"><a href="services#select"><span>.select(...args)</span></a></li></ul></li></ul><li><a href="services#create-relations"><span>Create Relations</span></a><ul><li class="leaf"><a href="services#one-to-one"><span>One to one</span></a></li><li class="leaf"><a href="services#one-to-many"><span>One to many</span></a></li><li class="leaf"><a href="services#many-to-many"><span>Many to many</span></a></li></ul></li><li><a href="services#query-with-associations"><span>Queries with associations</span></a><ul><li class="leaf"><a href="services#include"><span>.include(...associations)</span></a></li></ul></li></li></ul></nav></div></header><main id="main"><h1 id="performances">Performances</h1><p>Comparing fairly different data access libraries would be a bit complicated as the performances may vary for a wide range of reasons,
mainly related to the database itself:
the size of the tables, the indexes created, etc.
However ship hold repository contains an <a href="https://github/zorro-del-caribe/ship-hold/">example folder</a> in
which you can find some "real" use cases for our publishing platform with implementations for various libraries. This is not a benchmark,
it is meant to give you a toy application to compare the different user experiences and test how (in)efficient queries with associations can be.
Therefore queries are monitored and execution time is measured.
</p><p>  The listed pretty common use cases are the following:</p><ul><li><p>Create a home page where we want to display the latest posts (10) including the three last published comments with their author's data,
the tags related to each posts and the posts authors' data.</p></li><li><p>Create a user profile page where we want to display the latest comments (5) of a given user including some reference data to the post in which the comment
took place.
We also want to get the five last posts published by the user including the tags for each post.</p></li><li><p>Create a list of posts for a given tag. We want to list the five most recent posts including the data related to the author, and the three last comments.

</p></li></ul><article><h2 id="result">Result</h2><p>With a data set of 100 000 users, 20 000 posts, 120 000 comments and around 200 tags, I get on my machine this kind of result.
No index has been added, which is somehow unrealistic, but as the nature of queries generated by the different libraries is very different,
that would make it even more complicated to compare. Of course you are invited to run your tests with indexes.
</p><table><caption>execution time of listed use cases with different libraries</caption><tbody><tr><th scope="col">Case</th><th scope="col">ship-hold</th><th scope="col">sequelize</th><th scope="col">objection</th></tr><tr><th scope="row">latest posts</th><td>55ms</td><td>149ms</td><td>111ms</td></tr><tr><th scope="row">user profile</th><td>53ms</td><td>102ms</td><td>81ms</td></tr><tr><th scope="row">posts by tag</th><td>164ms</td><td>ERROR</td><td>338ms</td></tr></tbody></table></article><article><h2 id="why">Why ?</h2><p>Why ship hold appears to perform so well compared to well established libraries ?
</p><p>First of all, ship-hold remains a quite low level abstraction and does not do much other than building a SQL query, handing it to <i>pg</i> driver, and forward the response to
you application code. That'is why if you run a query directly with the driver or through ship-hold, you will get quite similar result:
</p><blockquote>Get five last articles including their authors' data</blockquote><pre class="hljs"><code>pg.query(<span class="hljs-string">`SELECT "posts".*, to_json("users".*) as "author"
                FROM 
            (SELECT * FROM "posts" ORDER BY "published_at" DESC LIMIT 5) as "posts" 
                JOIN "users" 
        ON "posts"."user_id" = "users"."user_id"
`</span>);

<span class="hljs-comment">// &gt; 18ms</span>


sh.select(<span class="hljs-string">'posts.*'</span>, {
    <span class="hljs-attr">value</span>: toJson(<span class="hljs-string">'"users".*'</span>),
    <span class="hljs-attr">as</span>: <span class="hljs-string">'author'</span>
})
    .from({
        <span class="hljs-attr">value</span>: sh.select()
            .from(<span class="hljs-string">'posts'</span>)
            .orderBy(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'desc'</span>)
            .limit(<span class="hljs-number">5</span>), <span class="hljs-attr">as</span>: <span class="hljs-string">'posts'</span>
    })
    .join(<span class="hljs-string">'users'</span>)
    .on(<span class="hljs-string">'posts.user_id'</span>, <span class="hljs-string">'"users"."user_id"'</span>)
    .run();

<span class="hljs-comment">// &gt; 23ms</span>

<span class="hljs-comment">// This one will actually generate different type of query but will get the same result</span>
Posts
    .select()
    .orderBy(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'desc'</span>)
    .limit(<span class="hljs-number">5</span>)
    .include(Users)
    .run();

<span class="hljs-comment">// &gt; 26ms</span>

<span class="hljs-comment">// As indication, with Sequelize I get something like 76ms</span>
</code></pre><p>On the other hand, ORM usually do few things such as creating model instances from the rows, etc.
<strong>That is why you would use them after all</strong> !
</p><p>Second point, is that ship-hold only works with one database engine (Postgres) and tries a much as possible
to rely on the database features rather than implementing an equivalent on the Javascript side. <strong>SQL is very powerful !</strong>(and often under used).
For example, in ship-hold queries with associations would result in a unique query to the database,
and even the aggregation is done in that query.
Other libraries would send various queries, buffer the result and aggregate the result in Javascript.
</p><p>I see many advantages processing in that way:
</p><ul><li><p>It reduces <em>a lot</em> the amount of code to write and makes ship-hold a lightweight framework
compared to the others. Moreover the code required for aggregation for example, may be quite complicated and bug prone: less code, less problems!</p></li><li><p>Database makers strive to improve performances, and write usually faster code in C++, with better algorithms that I personally could do on the JS side.
Any performance improvement on the database engine would therefore improve ship-hold.</p></li><li><p>Join queries, and sub queries carry a part of redundant data. If you do the aggregation at the database level, I <em>suspect</em> that less data would need to
go throw the wires which might improve the performances compared to a solution where data is buffered on the JS side and cleaned/aggregated.
It could be especially true if your database is on a remote server.</p></li></ul></article><article><h2 id="where">Where ship hold would perform not so well ?</h2></article></main></body></html>