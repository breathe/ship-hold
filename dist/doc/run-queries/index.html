<html><head><title>Ship-hold | Run queries</title><base href="/ship-hold/dist/doc/"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="stylesheet" type="text/css" href="resources/theme.css"/><link rel="stylesheet" type="text/css" href="resources/darkula.css"/><link rel="icon" href="resources/ship-hold-logo.svg"/></head><body><header><div id="logo-wrapper"><img alt="ship-hold logo" src="resources/ship-hold-logo.svg"/><div><span>SHIP</span><span>-</span><span>HOLD</span></div></div><div id="main-navigation-container"><nav><ul><li class="top"><a href="./"><span>Introduction</span></a><ul><li><a href="./#getting-started"><span>Getting started</span></a><ul><li class="leaf"><a href="./#installation"><span>Installation</span></a></li><li class="leaf"><a href="./#initialisation"><span>Initialisation</span></a></li></ul></li><li><a href="./#how-to-read"><span>How to read this documentation</span></a></li></ul></li><li class="top"><a href="builders"><span>Builders</span></a><ul><li><a href="builders#build"><span>.build()</span></a><ul><li class="leaf"><a href="builders#parameterized-query"><span>Parameterized queries</span></a></li></ul></li><li><a href="builders#clone"><span>.clone()</span></a></li><li><a href="builders#with"><span>.with(as, build)</span></a></li><li><a href="builders#common-types"><span>Common types</span></a><ul><li class="leaf"><a href="builders#pointers"><span>Pointers</span></a></li><li class="leaf"><a href="builders#values"><span>Values</span></a></li></ul></li></ul></li><li class="top"><a href="builders/insert"><span>INSERT builder</span></a><ul><li><a href="builders/insert#insert"><span>.insert(map,...othersProps)</span></a></li><li><a href="builders/insert#into"><span>.into(tableName)</span></a></li><li><a href="builders/insert#values"><span>.values(rows)</span></a></li><li><a href="builders/insert#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/update"><span>UPDATE builder</span></a><ul><li><a href="builders/update#update"><span>.update(tableName)</span></a></li><li><a href="builders/update#set"><span>.set(mapOrString, ?value)</span></a></li><li><a href="builders/update#from"><span>.from(...pointers)</span></a></li><li><a href="builders/update#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/update#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/delete"><span>DELETE builder</span></a><ul><li><a href="builders/delete#delete"><span>.delete(tableName)</span></a></li><li><a href="builders/delete#using"><span>.using(...pointers)</span></a></li><li><a href="builders/delete#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/delete#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/select"><span>SELECT builder</span></a><ul><li><a href="builders/select#select"><span>.select(...pointers)</span></a></li><li><a href="builders/select#from"><span>.from(...pointers)</span></a></li><li><a href="builders/select#joins"><span>Joins</span></a><ul><li class="leaf"><a href="builders/select#join"><span>.join(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#left-join"><span>.leftJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#right-join"><span>rightJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#on"><span>.on(leftOperand, operator, rightOperand)</span></a></li></ul></li><li><a href="builders/select#group"><span>Group</span></a><ul><li class="leaf"><a href="builders/select#group-by"><span>.groupBy(...columns)</span></a></li><li class="leaf"><a href="builders/select#having"><span>.having(leftOp, operator, rightOp)</span></a></li></ul></li><li><a href="builders/select#where"><span>.where(leftOp, operator, rightOp)</span></a></li><li><a href="builders/select#pagination"><span>Pagination</span></a><ul><li class="leaf"><a href="builders/select#limit"><span>.limit(size, offset)</span></a></li></ul></li></ul></li><li class="top"><a href="builders/conditions"><span>Conditions builder</span></a><ul><li><a href="builders/conditions#factories"><span>Factories</span></a></li></ul></li><li class="top"><a href="run-queries"><span>Run queries</span></a><ul><li><a href="run-queries#run"><span>.run(params?:object)</span></a></li><li><a href="run-queries#debug"><span>.debug(params?:object)</span></a></li><li><a href="run-queries#stream"><span>.stream(sink: Generator, params?:object)</span></a></li></ul></li><li class="top"><a href="services"><span>Services</span></a><ul><li><a href="services#create-a-service"><span>Create a service</span></a><ul><li class="leaf"><a href="services#service"><span>.service(keyOrDef)</span></a></li></ul></li><li><a href="services#service-builders"><span>Service builders</span></a><ul><li class="leaf"><a href="services#insert"><span>.insert(...args)</span></a></li><li class="leaf"><a href="services#update"><span>.update(prosMap)</span></a></li><li class="leaf"><a href="services#delete"><span>.delete()</span></a></li><li class="leaf"><a href="services#select"><span>.select(...args)</span></a></li></ul></li></ul><li><a href="services#create-relations"><span>Create Relations</span></a><ul><li class="leaf"><a href="services#one-to-one"><span>One to one</span></a></li><li class="leaf"><a href="services#one-to-many"><span>One to many</span></a></li><li class="leaf"><a href="services#many-to-many"><span>Many to many</span></a></li></ul></li><li><a href="services#query-with-associations"><span>Queries with associations</span></a><ul><li class="leaf"><a href="services#include"><span>.include(...associations)</span></a></li></ul></li></li></ul></nav></div></header><main id="main"><h1 id="run-queries">Run queries</h1><p>So far we have only seen how to output the generated SQL of a builder thanks to the <a href="builders#build">build method</a>.
Obviously, at some point you will want to run your query against a true database. Depending on your use case and your preferences
one or the other of the following methods will be more adapted.
</p><p class="tip">As for the <code>build</code> method every method mentioned below lets you pass parameters for your parameterized queries.
</p><article><h2 id="run">.run(params?:object)</h2><p>This method returns a <em>Promise</em> which will eventually resolve with an array containing the rows returned by the driver. The promise will be rejected in case
the driver forwards an error. This is probably the method you are going to use the most.
</p><pre class="hljs"><code><span class="hljs-keyword">const</span> latestPostgresPosts = <span class="hljs-keyword">await</span> sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .where(<span class="hljs-string">'title'</span>, <span class="hljs-string">'ILIKE'</span>, <span class="hljs-string">'$title'</span>)
    .orderBy(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'desc'</span>)
    .run({
        <span class="hljs-attr">title</span>: <span class="hljs-string">'%postgres%'</span>
    });

<span class="hljs-comment">// latestPostgresPosts will be an array with all the posts</span>
<span class="hljs-comment">// whose title container "postgres", ordered by publication date</span>
</code></pre><p class="tip">In an async context, don't forget to use the <code>await</code> keyword
</p><p class="tip">If you know your result will be a single row, you can use a <strong>destructuring pattern</strong>: <code>const [user] = await sh.select().from('users').limit(1).run()</code>
</p></article><article><h2 id="debug">.debug(params?:object)</h2><p>This method is exactly the same than <a href="run-queries#run">run method</a>, but il will also print in the console the result of
<code>build</code> (ie with the SQL query used).
</p></article><article><h2 id="stream">.stream(sink: Generator, params?:object)</h2><p>This method is very useful if you want to process each row one by one as they come out the driver parser.
It will be particularly efficient if you want to process big amount of data without consuming too much cpu/memory as no data is buffered.
Ship-hold itself does not do any extra work on the data coming out the driver so it would also be a good extension point if you want to add extra layers on top of ship-hold:
for example if you want to build an ORM, you could create here model instances from the rows.
</p><p>The first argument is a generator as data sink. You can have a look at that <a href="">excellent book</a> if you want more details.
The second argument will be an object map with the parameters' values if you want to use a parameterized query.
</p><p class="tip">Note that such streams do not have back pressure implementation.
</p><p>Consider the following requirement:</p><blockquote>I want to create a dump JSON file of all the posts in the database with their authors' data.</blockquote><p>Our test database has only <em>20 000</em> posts but if you try to do something similar with others libraries you would likely hit a wall.
With ship-hold and the <code>stream</code> method it is pretty easy!
</p><pre class="hljs"><code>sh
    .select(<span class="hljs-string">'posts.*'</span>, {<span class="hljs-attr">value</span>: toJson(<span class="hljs-string">'"users".*'</span>), <span class="hljs-attr">as</span>: <span class="hljs-string">'author'</span>})
    .from(<span class="hljs-string">'posts'</span>)
    .leftJoin(<span class="hljs-string">'users'</span>)
    .on(<span class="hljs-string">'users.user_id'</span>, <span class="hljs-string">'"posts"."user_id"'</span>)
    .stream(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'['</span>);
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">const</span> r = <span class="hljs-keyword">yield</span>;
                <span class="hljs-keyword">if</span> (first) {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(r));
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">','</span> + <span class="hljs-built_in">JSON</span>.stringify(r));
                }
                first = <span class="hljs-literal">false</span>;
            }
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">']'</span>);
        }
    });
</code></pre><p>If I run the following command <code>time node ./my-program.js > dump.json</code> on my machine,
I manage to create a <strong>13Mb</strong> file in <strong>1.25 second</strong>!</p></article></main></body></html>