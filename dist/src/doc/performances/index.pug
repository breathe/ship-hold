extends ../common/main

include ../common/mixins

block content
    h1#performances Performances

    p.
        Comparing fairly different data access libraries would be a bit complicated as the performances may vary for a wide range of reasons,
        mainly related to the database itself:
        the size of the tables, the indexes created, etc.
        However ship hold repository contains an #[+link('https://github.com/zorro-del-caribe/ship-hold/tree/master/example','example folder')] in
        which you can find some #[i real] use cases for our publishing platform with implementations for various libraries. This is not a benchmark,
        it is meant to give you a toy application to compare the different user experiences and test how (in)efficient queries with associations can be.
        Therefore queries are monitored and execution time is measured.

    p   The listed pretty common use cases are the following:

    ul
        li
            p.
                Create a home page where we want to display the latest posts (10) including the three last published comments with their author's data,
                the tags related to each posts and the posts authors' data.
        li
            p.
                Create a user profile page where we want to display the latest comments (5) of a given user including some reference data to the post in which the comment
                took place.
                We also want to get the five last posts published by the user including the tags for each post.
        li
            p.
                Create a list of posts for a given tag. We want to list the five most recent posts including the data related to the author, and the three last comments.


    article
        h2#result Result

        p.
            With a data set of 100 000 users, 20 000 posts, 120 000 comments and around 200 tags, I get on my machine this kind of result.
            No index has been added, which is somehow unrealistic, but as the nature of queries generated by the different libraries is very different,
            that would make it even more complicated to compare. Of course you are invited to run your tests with indexes.

        table
            caption execution time of listed use cases with different libraries
            tbody
                tr
                    th(scope='col') Case
                    th(scope='col') ship-hold
                    th(scope='col') sequelize
                    th(scope='col') objection
                tr
                    th(scope='row') latest posts
                    td 55ms
                    td 149ms
                    td 111ms
                tr
                    th(scope='row') user profile
                    td 53ms
                    td 102ms
                    td 81ms
                tr
                    th(scope='row') posts by tag
                    td 164ms
                    td ERROR
                    td 338ms

    article
        h2#why Why ?

        p.
            Why does ship hold appear to perform so well compared to well established libraries ?

        p.
            First of all, ship-hold remains a quite low level abstraction and does not do much other than building a SQL query, handing it to #[i pg] driver, and forward the response to
            you application code. That's why if you run a query directly with the driver or through ship-hold, you will get quite similar result:

        blockquote Get five last articles including their authors' data

        +codeblock
            include:highlight(lang='javascript') snippets/ship-hold-pg.js

        p.
            On the other hand, ORM usually do few things such as creating model instances from the rows, etc.
            #[strong That is why you would use them after all] !

        p.
            Second point, is that ship-hold only works with one database engine (Postgres) and tries a much as possible
            to rely on the database features rather than implementing an equivalent on the Javascript side. #[strong SQL is very powerful !](and often under used).
            For example, in ship-hold, queries with associations would result in a unique query to the database,
            and even the aggregation is done in that query.
            Other libraries would send various queries, buffer the result and aggregate the result in Javascript.

        p.
            I see many advantages in processing that way:

        ul
            li
                p.
                    It reduces #[em a lot] the amount of code to write and makes ship-hold a lightweight framework
                    compared to the others. Moreover the code required for aggregation for example, may be quite complicated and bug prone: less code, less problems!
            li
                p.
                    Database makers strive to improve performances, and write usually faster code in C++, with better algorithms that I personally could do on the JS side.
                    Any performance improvement on the database engine would therefore improve ship-hold.
            li
                p.
                    Join queries, and sub queries carry a part of redundant data. If you do the aggregation at the database level, I #[em suspect] that less data would need to
                    go throw the wires which might improve the performances compared to a solution where data is buffered on the JS side and cleaned/aggregated.
                    It could be especially true if your database is on a remote server.
    article
        h2#where Where would ship hold perform not so well ?

        p.
            Even though I am trying to sell ship-hold to you, I must be honest. When I built ship-hold, I did not have performances particularly in mind.
            I tend to favor first user experience, simplicity of the code and extensible abstractions. The relative good performances is more or less an accident.
            As any software, at some point you have to make some trade of. This section will explain when ship-hold might not perform well.

        p.
            When you perform a query including associations, ship-hold uses behind the scene #[+link('https://devdocs.io/postgresql~10/queries-with#QUERIES-WITH-SELECT','Common Table Expressions')].
            CTE are useful in many ways but their main advantage is the readability they provide. They are eagerly evaluated (once only) and can be referenced in other part of the query (a bit like variable).
            This is very useful when you want to build a query recursively which is the case when you have many associations fetched at many levels of depth.

        p.
            On the other hand, CTE might not be simplified by Postgres query planner as their inline equivalent (at least for now). The fact that CTE are eagerly evaluated can also be a
            disadvantage

        p.
            If you run the following code

        +codeblock
            include:highlight(lang='javascript') snippets/performances-cte.js

        p.
            You will get the following SQL

        +codeblock
            include:highlight(lang='sql') snippets/performances-cte.sql

        p.
            This query will have a #[+link('https://devdocs.io/postgresql~10/sql-explain','cost')] relatively low. The first CTE #[code "Posts"] is referenced quite few times but only evaluated once.
            Moreover the scope of the query (posts whose author's id is 42) narrows down a lot the scope of the others dependant CTEs and sub queries.

        p.
            To sum up, when you quickly narrows down the scope of a select with include (by applying a pagination on the main builder for example), ship-hold's query will perform quite well.

        p.
            Now let's go back to #[+link('run-queries/index.html#stream','the example where we wanted to create a dump files of all our posts')].
            We had an impressive result there. But let's write our code with inclusions now

        +codeblock
            include:highlight(lang='javascript') snippets/performances-bad.js

        p.
            This time, it took us #[strong 52 seconds] to create the dump file (50x slower) !
            Let's have a look at the SQL

        +codeblock
            include:highlight(lang='sql') snippets/performances-bad.sql

        p.
            The first CTE is useless: it basically returns the whole posts table and worst, the second evaluates whether an id is in an array of 20 000 items.
            In fact it will returns all the users who are also authors (about 8000). Finally our sub query (the last select) will have to match 20 000 posts to those 8000 users.
            No wonder it takes time !

        p.
            To sum up, if your main query (the main builder) would probably returns a big subset, avoid query with inclusions. Luckily for us, ship-hold remains
            flexible and you are not out of tools when you spot such a case and need to workaround the issue.












