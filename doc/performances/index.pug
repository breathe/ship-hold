extends ../common/main

include ../common/mixins

block content
    h1#performances Performances

    p.
        Comparing fairly different data access libraries would be a bit complicated as the performances may vary for a wide range of reasons,
        mainly related to the database itself:
        the size of the tables, the indexes created, etc.
        However ship hold repository contains an #[+link('https://github/zorro-del-caribe/ship-hold/','example folder')] in
        which you can find some "real" use cases for our publishing platform with implementations for various libraries. This is not a benchmark,
        it is meant to give you a toy application to compare the different user experiences and test how (in)efficient queries with associations can be.
        Therefore queries are monitored and execution time is measured.

    p   The listed pretty common use cases are the following:

    ul
        li
            p.
                Create a home page where we want to display the latest posts (10) including the three last published comments with their author's data,
                the tags related to each posts and the posts authors' data.
        li
            p.
                Create a user profile page where we want to display the latest comments (5) of a given user including some reference data to the post in which the comment
                took place.
                We also want to get the five last posts published by the user including the tags for each post.
        li
            p.
                Create a list of posts for a given tag. We want to list the five most recent posts including the data related to the author, and the three last comments.


    article
        h2#result Result

        p.
            With a data set of 100 000 users, 20 000 posts, 120 000 comments and around 200 tags, I get on my machine this kind of result.
            No index has been added, which is somehow unrealistic, but as the nature of queries generated by the different libraries is very different,
            that would make it even more complicated to compare. Of course you are invited to run your tests with indexes.

        table
            caption execution time of listed use cases with different libraries
            tbody
                tr
                    th(scope='col') Case
                    th(scope='col') ship-hold
                    th(scope='col') sequelize
                    th(scope='col') objection
                tr
                    th(scope='row') latest posts
                    td 55ms
                    td 149ms
                    td 111ms
                tr
                    th(scope='row') user profile
                    td 53ms
                    td 102ms
                    td 81ms
                tr
                    th(scope='row') posts by tag
                    td 164ms
                    td ERROR
                    td 338ms

    article
        h2#why Why ?

        p.
            Why ship hold appears to perform so well compared to well established libraries ?

        p.
            First of all, ship-hold remains a quite low level abstraction and does not do much other than building a SQL query, handing it to #[i pg] driver, and forward the response to
            you application code. That'is why if you run a query directly with the driver or through ship-hold, you will get quite similar result:

        blockquote Get five last articles including their authors' data

        +codeblock
            include:highlight(lang='javascript') snippets/ship-hold-pg.js

        p.
            On the other hand, ORM usually do few things such as creating model instances from the rows, etc.
            #[strong That is why you would use them after all] !

        p.
            Second point, is that ship-hold only works with one database engine (Postgres) and tries a much as possible
            to rely on the database features rather than implementing an equivalent on the Javascript side. #[strong SQL is very powerful !](and often under used).
            For example, in ship-hold queries with associations would result in a unique query to the database,
            and even the aggregation is done in that query.
            Other libraries would send various queries, buffer the result and aggregate the result in Javascript.

        p.
            I see many advantages processing in that way:

        ul
            li
                p.
                    It reduces #[em a lot] the amount of code to write and makes ship-hold a lightweight framework
                    compared to the others. Moreover the code required for aggregation for example, may be quite complicated and bug prone: less code, less problems!
            li
                p.
                    Database makers strive to improve performances, and write usually faster code in C++, with better algorithms that I personally could do on the JS side.
                    Any performance improvement on the database engine would therefore improve ship-hold.
            li
                p.
                    Join queries, and sub queries carry a part of redundant data. If you do the aggregation at the database level, I #[em suspect] that less data would need to
                    go throw the wires which might improve the performances compared to a solution where data is buffered on the JS side and cleaned/aggregated.
                    It could be especially true if your database is on a remote server.
    article
        h2#where Where ship hold would perform not so well ?

        p.




