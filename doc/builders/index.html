<html><head><title>Ship-hold | Builders</title><base href="/ship-hold/doc/"/><link rel="stylesheet" type="text/css" href="common/theme.css"/><link rel="stylesheet" type="text/css" href="../node_modules/highlight.js/styles/darkula.css"/></head><body><header><div id="logo-wrapper"><img alt="ship-hold logo" src="resources/ship-hold-logo.svg"/><span>SHIP</span><span>-</span><span>HOLD</span></div><div id="main-navigation-container"><nav><ul><li class="top"><a href="introduction"><span>Introduction</span></a><ul><li><a href="introduction#getting-started"><span>Getting started</span></a><ul><li class="leaf"><a href="introduction#installation"><span>Installation</span></a></li><li class="leaf"><a href="introduction#initialisation"><span>Initialisation</span></a></li></ul></li><li><a href="introduction#how-to-read"><span>How to read this documentation</span></a></li></ul></li><li class="top"><a href="builders"><span>Builders</span></a><ul><li><a href="builders#build"><span>.build()</span></a><ul><li class="leaf"><a href="builders#parameterized-query"><span>Parameterized queries</span></a></li></ul></li><li><a href="builders#clone"><span>.clone()</span></a></li><li><a href="builders#with"><span>.with(as, build)</span></a></li><li><a href="builders#common-types"><span>Common types</span></a><ul><li class="leaf"><a href="builders#pointers"><span>Pointers</span></a></li><li class="leaf"><a href="builders#values"><span>Values</span></a></li></ul></li></ul></li><li class="top"><a href="builders/insert"><span>INSERT builder</span></a><ul><li><a href="builders/insert#insert"><span>.insert(map,...othersProps)</span></a></li><li><a href="builders/insert#into"><span>.into(tableName)</span></a></li><li><a href="builders/insert#values"><span>.values(rows)</span></a></li><li><a href="builders/insert#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/update"><span>UPDATE builder</span></a><ul><li><a href="builders/update#update"><span>.update(tableName)</span></a></li><li><a href="builders/update#set"><span>.set(mapOrString, ?value)</span></a></li><li><a href="builders/update#from"><span>.from(...pointers)</span></a></li><li><a href="builders/update#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/update#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/delete"><span>DELETE builder</span></a><ul><li><a href="builders/delete#delete"><span>.delete(tableName)</span></a></li><li><a href="builders/delete#using"><span>.using(...pointers)</span></a></li><li><a href="builders/delete#where"><span>.where(leftOperand, operator, rightOperand)</span></a></li><li><a href="builders/delete#returning"><span>.returning(...properties)</span></a></li></ul></li><li class="top"><a href="builders/select"><span>SELECT builder</span></a><ul><li><a href="builders/select#select"><span>.select(...pointers)</span></a></li><li><a href="builders/select#from"><span>.from(...pointers)</span></a></li><li><a href="builders/select#joins"><span>Joins</span></a><ul><li class="leaf"><a href="builders/select#join"><span>.join(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#left-join"><span>.leftJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#right-join"><span>rightJoin(table, leftOp, rightOp)</span></a></li><li class="leaf"><a href="builders/select#on"><span>.on(leftOperand, operator, rightOperand)</span></a></li></ul></li><li><a href="builders/select#group"><span>Group</span></a><ul><li class="leaf"><a href="builders/select#group-by"><span>.groupBy(...columns)</span></a></li><li class="leaf"><a href="builders/select#having"><span>.having(leftOp, operator, rightOp)</span></a></li></ul></li><li><a href="builders/select#where"><span>.where(leftOp, operator, rightOp)</span></a></li><li><a href="builders/select#pagination"><span>Pagination</span></a><ul><li class="leaf"><a href="builders/select#limit"><span>.limit(size, offset)</span></a></li></ul></li></ul></li></ul></nav></div></header><main id="main"><h1 id="builders">Builders</h1><p>A ship-hold instance provides a <strong>builder</strong> for each common database operation: <a href="builders/insert">INSERT</a>,
<a href="builders/update">UPDATE</a>, <a href="builders/delete">DELETE</a> and <a href="builders/select">SELECT</a>; and also a <a href="builders/conditions">conditions builder</a>
to create more sophisticated conditions.
</p><p>You will notice while reading this documentation that ship hold API closely mirrors the <a href="https://devdocs.io/postgreSQL~10-syntax/">SQL syntax</a>. This is on purpose to reduce the cognitive effort if you already know some SQL.
At first, it may seem less obvious to call a <em>select</em> function rather than a <em>findAll</em> (for example) one. But with time and especially if you learn SQL, you will undoubtedly see the benefits.
On the other hand while using ship-hold you will likely learn a bit of SQL!
So usually you can write a query as you would write it in SQL but by chaining function calls instead.
</p><p class="tip">Usually the call order does not really matter but it is recommended to follow the SQL grammar syntax
</p><article><h2 class="method" id="build">.build()</h2><p>Every builder comes with a <strong>build</strong> method to output the generated SQL. This is just string manipulation and does not need any database connection.
</p><pre class="hljs"><code>sh.select().from(<span class="hljs-string">'users'</span>).build();

<span class="hljs-comment">// &gt; { text: 'SELECT * FROM "users"', values: [] }</span>
</code></pre><h3 id="parameterized-query">Parameterized queries</h3><p>If you look at our previous example, you'll see the build method outputs an object whose <code>text</code> property has the generated SQL.
But there is also a <code>values</code> properties. This is because ship-hold allows you to execute <strong>parameterized queries</strong> to reduce
your exposure to <strong>SQL injections</strong>.
</p><p>To use parameters in your request just pass pointer strings prefixed with the dollar sign. You can then pass the actual parameter values
as an object map to the build method (or any other run method mentioned in the <a href="run-queries">run queries section</a>)
</p><pre class="hljs"><code>sh.select()
    .from(<span class="hljs-string">'users'</span>)
    .where(<span class="hljs-string">'first_name'</span>, <span class="hljs-string">'$name'</span>)
    .build({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Laurent'</span>
    });

<span class="hljs-comment">// &gt; { text: 'SELECT * FROM "users" WHERE "first_name" = $1', values: [ 'Laurent' ] }</span>
</code></pre></article><article><h2 class="method" id="clone">.clone()</h2><p>Every builder comes with a <em>clone</em> method which allows you to make a copy of an existing builder while leaving it untouched. It is
useful to avoid side effects when you use a builder as parameter of another builder.
</p><pre class="hljs"><code><span class="hljs-keyword">const</span> b = sh.select().from(<span class="hljs-string">'users'</span>);
<span class="hljs-keyword">const</span> b2 = b.clone().where(<span class="hljs-string">'first_name'</span>, <span class="hljs-string">'Laurent'</span>);

<span class="hljs-built_in">Object</span>.is(b, b2);
<span class="hljs-comment">// &gt; false</span>
b.build();
<span class="hljs-comment">// &gt; { text: 'SELECT * FROM "users"', values: [] }</span>
b2.build();
<span class="hljs-comment">// &gt; { text: 'SELECT * FROM "users" WHERE "first_name" = 'Laurent', values: [] }</span>
</code></pre></article><article><h2 class="method" id="with">.with(alias: string, builder: Builder)</h2><p>SELECT, UPDATE, DELETE and INSERT builders have the <strong>with</strong> method which let you create
<a href="https://devdocs.io/postgreSQL~10/queries-with#QUERIES-WITH-SELECT">Common Table Expression</a> statements. You pass the alias
as first argument and a builder as second argument
</p><pre class="hljs"><code>sh
    .select()
    .with(<span class="hljs-string">'old_articles'</span>, sh
        .delete()
        .from(<span class="hljs-string">'posts'</span>)
        .where(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))
        .returning(<span class="hljs-string">'*'</span>)
    )
    .from(<span class="hljs-string">'old_articles'</span>)
    .where(<span class="hljs-string">'user_id'</span>, <span class="hljs-number">42</span>)
    .build();

<span class="hljs-comment">// { text:</span>
<span class="hljs-comment">//     `WITH "old_articles" AS (DELETE FROM "posts" WHERE "published_at" &lt; '2000-02-01T05:00:00.000Z'</span>
<span class="hljs-comment">//      RETURNING *)</span>
<span class="hljs-comment">//      SELECT * FROM "old_articles" WHERE "user_id" = 42`,</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">You can chain <code>with</code> calls to create several common table expressions !
</p></article><article><h2 id="common-types">Common types</h2><p>The documentation often refer to some common types defined below</p><h3 id="pointers">Pointers</h3><p>Pointers are SQL entities which can design a column, a table or any expression that can enter into a SELECT clause.</p><p>If a pointer is a string it will automatically be wrapped within quotes following the postgres dialect. Also, any expression marked with a dot "." will be split
and every part will be wrapped as well.
</p><p>A pointer can also be an object with a <code>value</code> property and a <code>as</code> property. In this case the <em>as</em> will be
used as an alias for the value
</p><pre class="hljs"><code>sh
    .select(<span class="hljs-string">'posts.post_id'</span>, <span class="hljs-string">'published_at'</span>, {
        <span class="hljs-attr">as</span>: <span class="hljs-string">'author'</span>,
        <span class="hljs-attr">value</span>: sh.select(<span class="hljs-string">'*'</span>)
            .from(<span class="hljs-string">'users'</span>)
            .where(<span class="hljs-string">'users.user_id'</span>, <span class="hljs-string">'"posts"."user_id"'</span>)
            .noop()
    })
    .from(<span class="hljs-string">'posts'</span>)
    .build();

<span class="hljs-comment">//&gt; { text:</span>
<span class="hljs-comment">//    `SELECT "posts"."post_id", "published_at",</span>
<span class="hljs-comment">//     (SELECT * FROM "users" WHERE "users"."user_id" = "posts"."user_id") AS "author" FROM "posts"`,</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre><p class="tip">You will see the <a href="builders/conditions">conditions builder</a> in details but note the first operand of the where clause
is by default a pointer whereas the second is by default a value. It means if you want to set the second operand as a pointer, you
will need to wrap it within quotes yourself.
</p><h3 id="values">Values</h3><p>Values refer to any assignable value type: string, array, number, json, subquery. They will be casted by the pg driver.
They are often used as the second operand of a condition
</p><pre class="hljs"><code>sh
    .select()
    .from(<span class="hljs-string">'posts'</span>)
    .where(<span class="hljs-string">'post_id'</span>, <span class="hljs-string">'IN'</span>, [<span class="hljs-number">123</span>, <span class="hljs-number">543</span>, <span class="hljs-number">678</span>])
    .and(<span class="hljs-string">'published_at'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2015</span>))
    .and(<span class="hljs-string">'user_id'</span>, <span class="hljs-string">'IN'</span>, sh
        .select(<span class="hljs-string">'user_id'</span>)
        .from(<span class="hljs-string">'users'</span>)
        .where(<span class="hljs-string">'last_name'</span>, <span class="hljs-string">'ILIKE'</span>, <span class="hljs-string">'renard'</span>)
        .noop()
    )
    .build();

<span class="hljs-comment">//&gt; { text:</span>
<span class="hljs-comment">//    'SELECT * FROM "posts" WHERE "post_id" IN (123,543,678)</span>
<span class="hljs-comment">//     AND "published_at" &gt; '1970-01-01T00:00:02.015Z'</span>
<span class="hljs-comment">//     AND "user_id" IN</span>
<span class="hljs-comment">//          (SELECT "user_id" FROM "users" WHERE "last_name" ILIKE 'renard')',</span>
<span class="hljs-comment">//   values: [] }</span>
</code></pre></article></main></body></html>